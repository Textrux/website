import { ConstructElement } from "./ConstructElementInterfaces";
import { BaseConstruct } from "./ConstructInterfaces";
import { ConstructEvent } from "./ConstructEventInterfaces";

/**
 * Context for control execution
 */
export interface ControlContext {
  /** The construct this control is operating on */
  construct: BaseConstruct;

  /** The target element (if applicable) */
  targetElement?: ConstructElement;

  /** Current selection */
  selectedElements: ConstructElement[];

  /** Grid position context */
  gridContext: {
    row: number;
    col: number;
    rowCount: number;
    columnCount: number;
  };

  /** Control execution metadata */
  metadata: Record<string, any>;
}

/**
 * Result of control execution
 */
export interface ControlResult {
  /** Whether the control execution was successful */
  success: boolean;

  /** Events generated by this control execution */
  events: ConstructEvent[];

  /** Updated elements after control execution */
  updatedElements: ConstructElement[];

  /** Whether the grid structure was modified */
  gridModified: boolean;

  /** Error message if execution failed */
  error?: string;

  /** Additional result metadata */
  metadata: Record<string, any>;
}

/**
 * Base interface for construct controls
 */
export interface ConstructControl {
  /** Unique identifier for this control */
  id: string;

  /** Human-readable name */
  name: string;

  /** Description of what this control does */
  description: string;

  /** Control category (navigation, editing, structure, etc.) */
  category: string;

  /** Whether this control can be executed in the given context */
  canExecute(context: ControlContext): boolean;

  /** Execute the control */
  execute(context: ControlContext): Promise<ControlResult>;

  /** Undo the last execution of this control */
  undo?(context: ControlContext): Promise<ControlResult>;

  /** Whether this control supports undo */
  supportsUndo: boolean;
}

/**
 * Trigger for activating controls
 */
export interface ControlTrigger {
  /** Type of trigger */
  type: "keyboard" | "api" | "gesture" | "voice" | "timer" | "condition";

  /** Trigger configuration */
  config: Record<string, any>;

  /** Priority for this trigger (higher = checked first) */
  priority: number;

  /** Whether this trigger matches the current input */
  matches(input: TriggerInput): boolean;
}

/**
 * Input for trigger matching
 */
export interface TriggerInput {
  /** Type of input */
  type: "keyboard" | "api" | "gesture" | "voice" | "timer" | "condition";

  /** Input data */
  data: Record<string, any>;

  /** Context when input was received */
  context: ControlContext;
}

/**
 * Keyboard trigger configuration
 */
export interface KeyboardTrigger extends ControlTrigger {
  type: "keyboard";
  config: {
    key: string;
    modifiers?: ("ctrl" | "alt" | "shift" | "meta")[];
    preventDefault?: boolean;
    requireFocus?: boolean;
  };
}

/**
 * API trigger configuration
 */
export interface ApiTrigger extends ControlTrigger {
  type: "api";
  config: {
    endpoint: string;
    method?: "GET" | "POST" | "PUT" | "DELETE";
    authentication?: boolean;
  };
}

/**
 * Control binding - associates triggers with controls
 */
export interface ControlBinding {
  /** The control to execute */
  control: ConstructControl;

  /** Triggers that can activate this control */
  triggers: ControlTrigger[];

  /** Additional conditions for this binding */
  conditions?: ControlCondition[];

  /** Whether this binding is enabled */
  enabled: boolean;
}

/**
 * Condition for control activation
 */
export interface ControlCondition {
  /** Type of condition */
  type: "element-type" | "selection-state" | "construct-type" | "custom";

  /** Condition configuration */
  config: Record<string, any>;

  /** Check if condition is met */
  check(context: ControlContext): boolean;
}

/**
 * Control registry for managing available controls
 */
export interface ControlRegistry {
  /** Register a control */
  registerControl(control: ConstructControl): void;

  /** Unregister a control */
  unregisterControl(controlId: string): boolean;

  /** Get a control by ID */
  getControl(controlId: string): ConstructControl | undefined;

  /** Get all controls in a category */
  getControlsByCategory(category: string): ConstructControl[];

  /** Get all available controls */
  getAllControls(): ConstructControl[];

  /** Register a control binding */
  registerBinding(binding: ControlBinding): void;

  /** Get bindings for a specific trigger input */
  getBindingsForInput(input: TriggerInput): ControlBinding[];

  /** Execute the best matching control for given input */
  executeControl(
    input: TriggerInput,
    context: ControlContext
  ): Promise<ControlResult>;
}

/**
 * Standard construct controls
 */
export interface NavigationControl extends ConstructControl {
  category: "navigation";
}

export interface EditingControl extends ConstructControl {
  category: "editing";
}

export interface StructureControl extends ConstructControl {
  category: "structure";
}

export interface SelectionControl extends ConstructControl {
  category: "selection";
}

export interface FormattingControl extends ConstructControl {
  category: "formatting";
}

/**
 * Control execution history for undo/redo
 */
export interface ControlExecutionHistory {
  /** Record a control execution */
  record(
    control: ConstructControl,
    context: ControlContext,
    result: ControlResult
  ): void;

  /** Get the last executed control */
  getLastExecution(): ControlExecutionRecord | undefined;

  /** Undo the last control execution */
  undo(): Promise<ControlResult | undefined>;

  /** Redo the last undone control execution */
  redo(): Promise<ControlResult | undefined>;

  /** Clear execution history */
  clear(): void;

  /** Get execution history */
  getHistory(limit?: number): ControlExecutionRecord[];
}

/**
 * Record of a control execution
 */
export interface ControlExecutionRecord {
  /** The executed control */
  control: ConstructControl;

  /** Context at time of execution */
  context: ControlContext;

  /** Result of execution */
  result: ControlResult;

  /** Timestamp of execution */
  timestamp: number;

  /** Whether this execution was undone */
  undone: boolean;
}
